package com.example.mvpdemo.observerDemo.demo03

/**
 * @TODO: demo03
 * @Date: 2021/2/23 9:24
 * @User: lay
 */

//demo03
//相较于demo02 ，这个部分开始抽象通知者部分，而且由于观察和通知都只是一个行为，所以这个部分的抽象，应该都使用接口来实现
//1. 抽象观察行为；
//2. 抽象通知行为；
//3. 通过1和2，解除了双向耦合。通过观察者持有通知者、通知者在fun的参数中使用观察者的方式。
//4. 实现了事件流向图中，观察者实线指向通知者，通知者虚线通过订阅的方式返回结果。（3和4，分别说明了事件双向流动和实体类双向耦合的区别。）
//至此，基本上已经实现了观察者模式。

// 以上，就是观察者模式。观察者模式是双方通信的行为型模式。接口回调，是实现双方通信的手段。

//补充，接口回调。
//接口回调：本质就是（0、准备阶段。0.1 - 定义接口；0.2 - 接口中有方法的定义；0.3 - 实现接口的类；）使用阶段：（1、方法的参数是接口对象；）（2、然后我们调用这个方法，就形成了接口回调。）
//由于接口的实现是一个类，接口的所在环境是另一个类。这样自然就能形成两个类实例之间的数据传递。例如：fragment和Activity。

//观察者模式（Observer Pattern）.定义了一种一对多的通信模式。让多个观察者对象都观察同一个通知者。只要通知者发生变化，就会发出通知。
//让观察者们自行更新。（本质就是接口回调 + 双抽象解除双向耦合）

//观察者模式特点
//1. subject不需要知道observer的具体实例是哪些，observer 也不需要知道其他的observer是谁。
//2. 什么时候需要使用观察者模式？在A类（subject）变化，所有的B类（observer）就会跟着变化的时候。【特别是】在于不知道有多少B类都会跟着变化的时候。
//总结：其目的就是体现依赖倒转原则。依赖于抽象，不依赖于具体。

//六大设计原则才是面对对象的根本指导思想。

//Mvx 级别的结构设计也是根据业务需求来变化的。适合什么用什么。

//观察者模式不足
//1. 一个第三方的控件或者官方的控件，你不能通过接口的方式给他添加观察者的效果。 - 解决方法：写个子类继承这个控件类就可以。
//2. 观察者的具体实现类的调用方法不一定就是update(). - 解决：在具体类的update()重写方法中直接调用你要使用的方法。

//观察者模式已经学习完毕。
//对比开始：
//C#中事件委托的思路 - 【Kotlin 的委托 - 看看之后能不能实现。】

// 委托模式 - 就是代理模式 - 本质就是通过别的对象来实现自己的功能。
// 委托其实就是进一步解除【抽象通知者】和【抽象观察者】两者之间的对象实例持有关系。
// 直接通过在抽象通知者的具体实现类中添加【委托】的实例，并给【委托】中添加具体观察者的具体方法，以此来达到通知的目的。

// 思考：这样做有没有内存泄漏的风险？
// 回答：我猜测是有这个风险的。所以使用之后，对于【具体观察者】和【具体通知者】进行判空处理。 - 内存优化篇 - 之后强化学习的时候进行专门的梳理。
// 疑问：是不是每个对象在使用完成之后，都要进行判空处理？什么时候不需要？


interface Subject {

     var action:String

     fun attach(observer: Observer)

     fun detach(observer: Observer)

     fun notifyAllOb()

}